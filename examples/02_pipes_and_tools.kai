#!/usr/bin/env kaish
# Example 2: Pipes, redirects, and MCP tools
# Everything is a tool - builtins and MCP tools use same syntax

# Basic pipe - stdout of ls feeds stdin of grep
ls path=/src long=true | grep pattern="\.rs$"

# Redirect to virtual filesystem
ls path=/src recursive=true | grep pattern="\.rs$" > /scratch/rust_files.txt

# Read back (cat is a tool too)
cat /scratch/rust_files.txt

# Stdin from file with <
wc < /scratch/rust_files.txt

# Stderr redirect (keeping this simple)
risky-tool 2> /scratch/errors.log

# Both stdout and stderr
noisy-tool &> /scratch/all_output.log

# MCP tools look exactly like builtins - they're all just tools
# The namespace is the MCP server name
exa.web_search query="rust parser combinators"

# Access structured results
exa.web_search query="kaish shell"
echo "First result: ${?.data.results[0].title}"
echo "URL: ${?.data.results[0].url}"

# Pipe MCP tool output through processing
exa.web_search query="rust error handling" | jq path=".results[:3]" | each as=R | echo "${R.title}"

# Temp file dance when tools don't support stdin (- means stdin)
expensive-query > /scratch/data.json
transform input=- < /scratch/data.json > /scratch/transformed.json

# Or use a subshell/command substitution if we support it
# (TBD: do we want $(cmd) syntax?)
# transform input=$(expensive-query)

# Tool discovery - /bin is virtual, lists available tools
ls /bin                           # all tools
ls /bin/exa                       # tools from exa MCP server
ls /bin/builtin                   # builtin tools

# Tool help/schema
help tool=exa.web_search          # shows args, types, description
