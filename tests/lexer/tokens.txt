# Lexer Token Tests
# Format: INPUT | EXPECTED_TOKENS
# Use ERROR for expected lex failure

# === Keywords ===
set         | SET
local       | LOCAL
tool        | TOOL
if          | IF
then        | THEN
else        | ELSE
elif        | ELIF
fi          | FI
for         | FOR
in          | IN
do          | DO
done        | DONE

# === Identifiers ===
foo         | IDENT(foo)
foo_bar     | IDENT(foo_bar)
foo-bar     | IDENT(foo-bar)
_private    | IDENT(_private)
x1          | IDENT(x1)
123abc      | ERROR: identifier cannot start with digit

# === Integers ===
0           | INT(0)
123         | INT(123)
-456        | INT(-456)
999999999   | INT(999999999)

# === Floats ===
0.0         | FLOAT(0.0)
3.14        | FLOAT(3.14)
-2.5        | FLOAT(-2.5)
.5          | ERROR: float must have leading digit
5.          | ERROR: float must have trailing digit

# === Booleans ===
true        | BOOL(true)
false       | BOOL(false)
TRUE        | ERROR: ambiguous boolean, use lowercase 'true'
FALSE       | ERROR: ambiguous boolean, use lowercase 'false'
True        | ERROR: ambiguous boolean, use lowercase 'true'
yes         | ERROR: ambiguous boolean-like 'yes', use 'true' or '"yes"'
no          | ERROR: ambiguous boolean-like 'no', use 'false' or '"no"'
YES         | ERROR: ambiguous boolean-like 'YES', use 'true' or '"YES"'
NO          | ERROR: ambiguous boolean-like 'NO', use 'false' or '"NO"'

# === Double-Quoted Strings (with interpolation) ===
"hello"             | STRING(hello)
"hello world"       | STRING(hello world)
""                  | STRING()
"line\nbreak"       | STRING(line\nbreak)
"tab\there"         | STRING(tab\there)
"quote\"here"       | STRING(quote"here)
"slash\\here"       | STRING(slash\here)
"unicode\u0041"     | STRING(unicodeA)
"unterminated       | ERROR: unterminated string

# === Single-Quoted Strings (literal, no interpolation) ===
'hello'             | SINGLESTRING(hello)
'hello world'       | SINGLESTRING(hello world)
''                  | SINGLESTRING()
'no $VAR here'      | SINGLESTRING(no $VAR here)
'no escapes: \n'    | SINGLESTRING(no escapes: \n)
'unterminated       | ERROR: unterminated single-quoted string

# === Variable References ===
# Braced form (required for paths)
${X}                | VARREF(${X})
${foo}              | VARREF(${foo})
${foo_bar}          | VARREF(${foo_bar})
${X.field}          | VARREF(${X.field})
${X[0]}             | VARREF(${X[0]})
${X.a.b[0].c}       | VARREF(${X.a.b[0].c})
${?.ok}             | VARREF(${?.ok})
${?.data.x}         | VARREF(${?.data.x})
${                  | ERROR: unterminated variable reference
${X                 | ERROR: unterminated variable reference

# Simple form (identifiers only, no paths)
$X                  | SIMPLEVARREF(X)
$foo                | SIMPLEVARREF(foo)
$foo_bar            | SIMPLEVARREF(foo_bar)
$_private           | SIMPLEVARREF(_private)

# === Operators ===
=           | EQ
==          | EQEQ
!=          | NEQ
<           | LT
>           | GT
<=          | LEQ
>=          | GEQ
|           | PIPE
&           | AMP
&&          | AMPAMP
||          | PIPEPIPE

# === Redirects ===
>           | REDIR_OUT
>>          | REDIR_APPEND
<           | REDIR_IN
2>          | REDIR_ERR
&>          | REDIR_BOTH

# === Brackets ===
{           | LBRACE
}           | RBRACE
[           | LBRACK
]           | RBRACK
(           | LPAREN
)           | RPAREN
# Note: [[ and ]] are two separate bracket tokens (not TESTSTART/TESTEND)
# This allows nested arrays like [[1, 2], [3, 4]] to work correctly
[[          | LBRACK LBRACK
]]          | RBRACK RBRACK

# === Punctuation ===
,           | COMMA
:           | COLON
;           | SEMI
.           | DOT

# === Whitespace & Comments ===
"  spaces  "        | STRING(  spaces  )
# comment           | COMMENT( comment)
#                   | COMMENT()

# === Flags ===
# Short flags
-l                  | SHORTFLAG(l)
-a                  | SHORTFLAG(a)
-la                 | SHORTFLAG(la)
-vvv                | SHORTFLAG(vvv)

# Long flags
--force             | LONGFLAG(force)
--verbose           | LONGFLAG(verbose)
--foo-bar           | LONGFLAG(foo-bar)
--message           | LONGFLAG(message)

# Plus flags (for set +e)
+e                  | PLUSFLAG(e)
+x                  | PLUSFLAG(x)
+ex                 | PLUSFLAG(ex)

# Double dash (end of flags marker)
--                  | DOUBLEDASH

# Edge case: triple dash is invalid
---                 | ERROR: invalid flag syntax

# Edge case: single dash is positional (often means stdin)
-                   | ERROR: single dash not valid as flag

# Edge case: flags vs negative numbers
-123                | INT(-123)
-1                  | INT(-1)
-l                  | SHORTFLAG(l)
-1a                 | INT(-1) IDENT(a)

# === Combined Sequences ===
set X = 5           | SET IDENT(X) EQ INT(5)
echo "hi"           | IDENT(echo) STRING(hi)
cmd a=1 b=2         | IDENT(cmd) IDENT(a) EQ INT(1) IDENT(b) EQ INT(2)
a | b | c           | IDENT(a) PIPE IDENT(b) PIPE IDENT(c)
x > file            | IDENT(x) REDIR_OUT IDENT(file)

# Flag sequences
ls -l               | IDENT(ls) SHORTFLAG(l)
ls -la              | IDENT(ls) SHORTFLAG(la)
git --force         | IDENT(git) LONGFLAG(force)
git push --force    | IDENT(git) IDENT(push) LONGFLAG(force)
set -e              | SET SHORTFLAG(e)
set +e              | SET PLUSFLAG(e)
set -e -u           | SET SHORTFLAG(e) SHORTFLAG(u)
cmd -- -flag        | IDENT(cmd) DOUBLEDASH SHORTFLAG(flag)
