# Evaluation Tests: Runtime Behavior
# Format:
#   # test: name
#   # expect: ok | error
#   ---
#   script
#   ---
#   stdout: expected stdout
#   stderr: expected stderr (optional)
#   exit: expected exit code
#   ===

# ============================================================
# ECHO & BASIC OUTPUT
# ============================================================

# test: echo_string
# expect: ok
---
echo "hello"
---
stdout: hello
exit: 0
===

# test: echo_multiple
# expect: ok
---
echo "hello" "world"
---
stdout: hello world
exit: 0
===

# test: echo_empty
# expect: ok
---
echo ""
---
stdout:
exit: 0
===

# test: echo_escapes
# expect: ok
---
echo "line\nbreak"
---
stdout: line
break
exit: 0
===

# ============================================================
# VARIABLES
# ============================================================

# test: var_simple
# expect: ok
---
set X = "hello"
echo ${X}
---
stdout: hello
exit: 0
===

# test: var_int
# expect: ok
---
set N = 42
echo ${N}
---
stdout: 42
exit: 0
===

# test: var_reassign
# expect: ok
---
set X = "first"
set X = "second"
echo ${X}
---
stdout: second
exit: 0
===

# test: var_interpolation
# expect: ok
---
set NAME = "world"
echo "hello ${NAME}!"
---
stdout: hello world!
exit: 0
===

# test: var_multiple_interpolation
# expect: ok
---
set A = "one"
set B = "two"
echo "${A} and ${B}"
---
stdout: one and two
exit: 0
===

# test: var_nested_access
# expect: ok
---
set OBJ = {name: "alice", age: 30}
echo ${OBJ.name}
---
stdout: alice
exit: 0
===

# test: var_array_index
# expect: ok
---
set LIST = ["a", "b", "c"]
echo ${LIST[1]}
---
stdout: b
exit: 0
===

# test: var_undefined
# expect: error
---
echo ${NOPE}
---
stderr: error: undefined variable 'NOPE'
exit: 1
===

# test: var_undefined_nested
# expect: error
---
set X = {a: 1}
echo ${X.b}
---
stderr: error: undefined field 'b' in variable 'X'
exit: 1
===

# ============================================================
# EXIT CODE ($?) - Now an integer like bash
# ============================================================

# test: exit_code_is_integer
# expect: ok
---
echo "test"
echo $?
---
stdout: test
0
exit: 0
===

# test: exit_code_after_failure
# expect: ok
---
false-cmd
echo $?
---
stdout: 1
exit: 0
===

# test: exit_code_field_access
# expect: ok
---
echo "test"
echo ${?.code}
---
stdout: test
0
exit: 0
===

# test: exit_code_ok_field
# expect: ok
---
echo "test"
echo ${?.ok}
---
stdout: test
true
exit: 0
===

# ============================================================
# COMMAND SUBSTITUTION - Capture structured output
# ============================================================

# test: cmd_subst_capture
# expect: ok
---
RESULT=$(json-echo '{"x": 42}')
echo ${RESULT.x}
---
stdout: 42
exit: 0
===

# ============================================================
# BASH-STYLE ASSIGNMENTS
# ============================================================

# test: bash_assign
# expect: ok
---
NAME="world"
echo "hello $NAME"
---
stdout: hello world
exit: 0
===

# test: local_assign
# expect: ok
---
local X = "local"
echo $X
---
stdout: local
exit: 0
===

# ============================================================
# SINGLE-QUOTED STRINGS
# ============================================================

# test: single_quote_literal
# expect: ok
---
X="world"
echo 'hello $X'
---
stdout: hello $X
exit: 0
===

# test: single_quote_escapes
# expect: ok
---
echo 'no escapes: \n here'
---
stdout: no escapes: \n here
exit: 0
===

# ============================================================
# CONDITIONALS
# ============================================================

# test: if_true_branch
# expect: ok
---
set X = true
if ${X}; then
    echo "yes"
fi
---
stdout: yes
exit: 0
===

# test: if_false_branch
# expect: ok
---
set X = false
if ${X}; then
    echo "yes"
fi
---
stdout:
exit: 0
===

# test: if_else_true
# expect: ok
---
set X = true
if ${X}; then
    echo "yes"
else
    echo "no"
fi
---
stdout: yes
exit: 0
===

# test: if_else_false
# expect: ok
---
set X = false
if ${X}; then
    echo "yes"
else
    echo "no"
fi
---
stdout: no
exit: 0
===

# test: if_result_ok
# expect: ok
---
echo "test"
if ${?.ok}; then
    echo "success"
fi
---
stdout: test
success
exit: 0
===

# test: if_command_succeeds
# expect: ok
---
if true-cmd; then
    echo "passed"
fi
---
stdout: passed
exit: 0
===

# test: if_command_fails
# expect: ok
---
if false-cmd; then
    echo "yes"
else
    echo "no"
fi
---
stdout: no
exit: 0
===

# test: if_comparison_gt
# expect: ok
---
set X = 10
if (${X} > 5); then
    echo "big"
fi
---
stdout: big
exit: 0
===

# test: if_comparison_eq
# expect: ok
---
set X = "test"
if (${X} == "test"); then
    echo "match"
fi
---
stdout: match
exit: 0
===

# ============================================================
# LOOPS
# ============================================================

# test: for_array
# expect: ok
---
for X in [1, 2, 3]; do
    echo ${X}
done
---
stdout: 1
2
3
exit: 0
===

# test: for_variable
# expect: ok
---
set ITEMS = ["a", "b", "c"]
for I in ${ITEMS}; do
    echo ${I}
done
---
stdout: a
b
c
exit: 0
===

# test: for_empty
# expect: ok
---
for X in []; do
    echo ${X}
done
---
stdout:
exit: 0
===

# ============================================================
# AND/OR CHAINS
# ============================================================

# test: and_both_succeed
# expect: ok
---
true-cmd && echo "both"
---
stdout: both
exit: 0
===

# test: and_first_fails
# expect: ok
---
false-cmd && echo "both"
---
stdout:
exit: 1
===

# test: or_first_succeeds
# expect: ok
---
true-cmd || echo "fallback"
---
stdout:
exit: 0
===

# test: or_first_fails
# expect: ok
---
false-cmd || echo "fallback"
---
stdout: fallback
exit: 0
===

# test: chain_and_or
# expect: ok
---
false-cmd && echo "no" || echo "fallback"
---
stdout: fallback
exit: 0
===

# ============================================================
# PIPES
# ============================================================

# test: pipe_simple
# expect: ok
---
echo "hello" | cat
---
stdout: hello
exit: 0
===

# test: pipe_transform
# expect: ok
---
echo "hello world" | upper
---
stdout: HELLO WORLD
exit: 0
===

# test: pipe_chain
# expect: ok
---
echo "hello" | upper | reverse
---
stdout: OLLEH
exit: 0
===

# test: pipe_filter
# expect: ok
---
echo "line1\nline2\nline3" | grep pattern="2"
---
stdout: line2
exit: 0
===

# ============================================================
# REDIRECTS
# ============================================================

# test: redirect_write
# expect: ok
---
echo "content" > /scratch/test.txt
cat /scratch/test.txt
---
stdout: content
exit: 0
===

# test: redirect_append
# expect: ok
---
echo "first" > /scratch/test.txt
echo "second" >> /scratch/test.txt
cat /scratch/test.txt
---
stdout: first
second
exit: 0
===

# test: redirect_input
# expect: ok
---
echo "input data" > /scratch/in.txt
cat < /scratch/in.txt
---
stdout: input data
exit: 0
===

# ============================================================
# TOOL DEFINITIONS
# ============================================================

# test: tool_call_simple
# expect: ok
---
tool greet name:string {
    echo "hello ${name}"
}
greet name="world"
---
stdout: hello world
exit: 0
===

# test: tool_call_default
# expect: ok
---
tool greet name:string="stranger" {
    echo "hello ${name}"
}
greet
---
stdout: hello stranger
exit: 0
===

# test: tool_call_override_default
# expect: ok
---
tool greet name:string="stranger" {
    echo "hello ${name}"
}
greet name="friend"
---
stdout: hello friend
exit: 0
===

# test: tool_with_pipeline
# expect: ok
---
tool shout msg:string {
    echo ${msg} | upper
}
shout msg="hello"
---
stdout: HELLO
exit: 0
===

# test: tool_missing_required
# expect: error
---
tool greet name:string {
    echo "hello ${name}"
}
greet
---
stderr: error: missing required parameter 'name' for tool 'greet'
exit: 1
===

# ============================================================
# BACKGROUND JOBS
# ============================================================

# test: background_single
# expect: ok
---
echo "bg" > /scratch/bg.txt &
wait
cat /scratch/bg.txt
---
stdout: bg
exit: 0
===

# test: background_multiple
# expect: ok
---
echo "a" > /scratch/a.txt &
echo "b" > /scratch/b.txt &
wait
cat /scratch/a.txt
cat /scratch/b.txt
---
stdout: a
b
exit: 0
===

# ============================================================
# SCATTER/GATHER
# ============================================================

# test: scatter_gather_basic
# expect: ok
---
echo "[1, 2, 3]" | scatter as=N | double n=${N} | gather
---
stdout: [2, 4, 6]
exit: 0
===

# test: scatter_gather_strings
# expect: ok
---
echo '["a", "b", "c"]' | scatter as=X | upper-str s=${X} | gather
---
stdout: ["A", "B", "C"]
exit: 0
===

# test: scatter_limit
# expect: ok
# Note: order may vary but all items processed
---
echo "[1, 2, 3, 4]" | scatter as=N limit=2 | identity n=${N} | gather
---
stdout: [1, 2, 3, 4]
exit: 0
===

# test: scatter_gather_preserves_order
# expect: ok
---
echo "[3, 1, 4, 1, 5]" | scatter as=N | identity n=${N} | gather
---
stdout: [3, 1, 4, 1, 5]
exit: 0
===

# ============================================================
# TEST EXPRESSIONS [[ ]]
# ============================================================

# test: test_file_exists
# expect: ok
---
[[ -f /etc/hosts ]] && echo "exists"
---
stdout: exists
exit: 0
===

# test: test_file_not_exists
# expect: ok
---
[[ -f /nonexistent/file ]] && echo "exists" || echo "missing"
---
stdout: missing
exit: 0
===

# test: test_string_comparison
# expect: ok
---
X="value"
if [[ $X == "value" ]]; then
    echo "match"
fi
---
stdout: match
exit: 0
===

# test: test_numeric_comparison
# expect: ok
---
NUM=10
if [[ $NUM -gt 5 ]]; then
    echo "big"
fi
---
stdout: big
exit: 0
===

# test: test_string_empty
# expect: ok
---
X=""
if [[ -z $X ]]; then
    echo "empty"
fi
---
stdout: empty
exit: 0
===

# test: test_string_nonempty
# expect: ok
---
X="hello"
if [[ -n $X ]]; then
    echo "has value"
fi
---
stdout: has value
exit: 0
===

# ============================================================
# STATEMENT CHAINING (bash-style)
# ============================================================

# test: chain_and_short_circuit
# expect: ok
---
false-cmd && echo "nope"
echo "done"
---
stdout: done
exit: 0
===

# test: chain_or_fallback
# expect: ok
---
false-cmd || echo "fallback"
---
stdout: fallback
exit: 0
===

# test: chain_success_no_fallback
# expect: ok
---
echo "first" || echo "fallback"
---
stdout: first
exit: 0
===
